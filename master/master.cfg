# -*- python -*-
# ex: set syntax=python:

# This is a sample buildmaster config file. It must be installed as
# 'master.cfg' in your buildmaster's base directory.

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

rust_git = 'git://github.com/mozilla/rust.git'

all_branches = ["master", "incoming", "try",
                "snap-stage3", "dist-snap"]

quick_platforms = ["mac", "linux", "win"]
full_platforms = quick_platforms + ["bsd"]
snap_platforms = full_platforms
dist_platforms = ["linux", "win"]
doc_platform = "linux"

####### BUILDSLAVES

# The 'slaves' list defines the set of recognized buildslaves. Each element is
# a BuildSlave object, specifying a unique slave name and password.  The same
# slave name and password must be configured on the slave.
from buildbot.buildslave import BuildSlave

c['slaves'] = []
for line in open("slave-list.txt"):
    if line.startswith("#"):
        continue
    fields = line.split()
    if len(fields) != 2:
        continue
    c['slaves'].append(BuildSlave(fields[0], fields[1]))


# We listen for slaves only on localhost; there should be an stunnel
# loopback forwarding to here.

c['slavePortnum'] = "tcp:9989:interface=127.0.0.1"

####### CHANGESOURCES

# the 'change_source' setting tells the buildmaster how it should find out
# about source code changes.

from buildbot.changes.gitpoller import GitPoller

main_sources = [GitPoller(rust_git,
                          workdir='gitpoller-workdir-%s' % b,
                          branch=b,
                          pollinterval=60) for b in all_branches]

c['change_source'] = main_sources

####### SCHEDULERS

# Configure the Schedulers, which decide how to react to incoming changes.

from buildbot.schedulers.basic import AnyBranchScheduler
from buildbot.changes import filter

try_sched = AnyBranchScheduler(
    name="try-quick-sched",
    change_filter=filter.ChangeFilter(branch='try'),
    treeStableTimer=None,
    builderNames=["quick-" + p for p in quick_platforms])

incoming_sched = AnyBranchScheduler(
    name="incoming-quick-sched",
    change_filter=filter.ChangeFilter(branch='incoming'),
    treeStableTimer=5*60,
    builderNames=["quick-" + p for p in quick_platforms])

full_sched = AnyBranchScheduler(
    name="full-sched",
    change_filter=filter.ChangeFilter(branch=['master',
                                              'incoming']),
    treeStableTimer=30*60,
    builderNames=["full-" + p for p in full_platforms])

doc_sched = AnyBranchScheduler(
    name="doc-sched",
    change_filter=filter.ChangeFilter(branch='master'),
    treeStableTimer=30*60,
    builderNames=["doc"])

snap_sched = AnyBranchScheduler(
    name="snap3-sched",
    change_filter=filter.ChangeFilter(branch='snap-stage3'),
    treeStableTimer=None,
    builderNames=["snap3-" + p for p in snap_platforms])

dist_sched = AnyBranchScheduler(
    name="dist-sched",
    change_filter=filter.ChangeFilter(branch='dist-snap'),
    treeStableTimer=None,
    builderNames=["dist-" + p for p in dist_platforms])

c['schedulers'] = [
try_sched,
incoming_sched,
full_sched,
doc_sched,
snap_sched,
dist_sched
]

####### BUILDERS

# The 'builders' list defines the Builders, which tell Buildbot how to perform a build:
# what steps, and which slaves can execute them.  Note that any particular build will
# only take place on one slave.

from buildbot.process.factory import BuildFactory
from buildbot.steps.source.git import Git
from buildbot.steps.shell import ShellCommand, Configure, Compile, Test, SetProperty
from buildbot.steps.slave import RemoveDirectory
from buildbot.config import BuilderConfig


# doStepIf helper
def should_wipe(step):
    props = step.build.getProperties()
    if props.has_key("wipe"):
        return True
    if props.has_key("oldfiles"):
        return props["oldfiles"] != "0"
    return False
    

def do_build(platform,
             mk_targets=None,
             cfg_args=[],
             full_meth=None):
    global rust_git
    f = BuildFactory()

    # This is required to trigger certain workarounds
    # done slave-side by buildbot. In particular omitting
    # the PWD variable with an unmangled pathname.
    env = None
    if "win" in platform:
        env = {"MACHTYPE": "i686-pc-msys",
               "MSYSTEM": "MINGW32"}

    # We wipe if the user requests it or if there are any files
    # older than 5 days in the build dir
    f.addStep(SetProperty(command="sh -c '/usr/bin/find . -ctime +5 | wc -l'",
                          property="oldfiles"))
    f.addStep(RemoveDirectory("build",
                              doStepIf=should_wipe))

    if full_meth != None:
        f.addStep(Git(repourl=rust_git,
                      progress=True,
                      retryFetch=True,
                      clobberOnFailure=True,
                      mode='full',
                      method=full_meth))
    else:
        f.addStep(Git(repourl=rust_git,
                      progress=True,
                      retryFetch=True,
                      clobberOnFailure=True,
                      mode='incremental'))

    f.addStep(Configure(env=env,
                        command=["sh", "-c", 
                                 "../configure " +
                                 " ".join(cfg_args)],
                        workdir="build/obj"))

    # Temporary until we convince the build system
    # to handle 0.x 0.x+1 co-occurrence in workspace
    f.addStep(Compile(env=env,
                      description="make clean",
                      descriptionDone="cleaned",
                      workdir="build/obj",
                      command=["make", "clean"]))

    f.addStep(Compile(env=env,
		      timeout=3600,
                      workdir="build/obj"))
    for t in mk_targets:

        # Entirely non-ideal override for windows
        # to run check-fast rather than check.
        if t == "check" and "win" in platform:
            t = "check-fast"

        f.addStep(Test(env=env,
                       command=["make", t],
		       timeout=3600,
                       workdir="build/obj"))
    return f

c['builders'] = []

def platform_slaves(p):
    return [slave.slavename
            for slave in c['slaves']
            if p in slave.slavename]

for p in quick_platforms:
    # Builder that does incremental-make-check-lite runs,
    # host=target only, no valgrind, no perf.
    c['builders'].append(BuilderConfig(
            mergeRequests=False,
            name="quick-" + p,
            category="quick",
            slavenames=platform_slaves(p),
            factory=do_build(p, ["check-lite"],
                             ["--disable-valgrind",
                              "--disable-docs"])))

for p in full_platforms:
    # Builder that does a full, laborious from-scratch build
    # on all targets, checks valgrind, profiles code, etc.
    c['builders'].append(BuilderConfig(
            mergeRequests=True,
            name="full-" + p,
            category="full",
            slavenames=platform_slaves(p),
            factory=do_build(p, ["check"], [], "fresh")))

for p in snap_platforms:
    # Builder that does whatever's needed to make stage3 snaps.
    c['builders'].append(BuilderConfig(
            mergeRequests=True,
            name="snap3-" + p,
            category="util",
            slavenames=platform_slaves(p),
            factory=do_build(p, ["snap-stage3"], [], "fresh")))

for p in dist_platforms:
    # Builder that does whatever's needed to make releases.
    c['builders'].append(BuilderConfig(
            mergeRequests=True,
            name="dist-" + p,
            category="util",
            slavenames=platform_slaves(p),
            factory=do_build(p, ["check",
                              "distcheck"],
                             [],
                             "fresh")))

# Builder that does whatever's needed to make docs.
c['builders'].append(BuilderConfig(
        mergeRequests=True,
        name="doc",
        category="util",
        slavenames=platform_slaves(doc_platform),
        factory=do_build(doc_platform, ["docs"])))


####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []

from buildbot.status import html
from buildbot.status.web import authz
authz_cfg=authz.Authz(
    # change any of these to True to enable; see the manual for more
    # options
    gracefulShutdown = False,
    forceBuild = True, # use this to test your slave once it is set up
    forceAllBuilds = True,
    pingBuilder = True,
    stopBuild = True,
    stopAllBuilds = True,
    cancelPendingBuild = True,
    showUsersPage = True,
)
c['status'].append(html.WebStatus(
        revlink='http://github.com/mozilla/rust/commit/%s',
        order_console_by_time=True,
        #http_port="tcp:8010:interface=127.0.0.1",
        http_port="tcp:8010",
        authz=authz_cfg))

from buildbot.status import words
c['status'].append(words.IRC(host="irc.mozilla.org",
                             nick="gypsy",
                             channels=["#rust"]))

####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot
# installation's html.WebStatus home page (linked to the
# 'titleURL') and is embedded in the title of the waterfall HTML page.

c['title'] = "Rust"
c['titleURL'] = "http://rust-lang.org"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.WebStatus page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.

c['buildbotURL'] = "http://rust1.vm.labs.scl3.mozilla.com:8010/"

####### DB URL

# This specifies what database buildbot uses to store change and scheduler
# state.  You can leave this at its default for all but the largest
# installations.
c['db_url'] = "sqlite:///state.sqlite"

